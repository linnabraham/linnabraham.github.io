<!DOCTYPE html>
<html lang="en">
<head>
	<title>Git and Related Concepts | Linn Abraham&#39;s homepage</title>
	<link rel="canonical" href="https://linnabraham.me/">
	<link rel='alternate' type='application/rss+xml' title="Linn Abraham&#39;s homepage RSS" href='/index.xml'>
	<link rel='stylesheet' type='text/css' href='/style.css'>
	<link rel="icon" href="/favicon.ico">
	<meta name="description" content="Basic usage diff See my notes on Understanding Diff. To see the changes that are brought about by a particular commit in git, do the following:
git diff &lt;parent-commit&gt;..&lt;current-commit&gt; staging The changes that you to immediately make to your git tracked files are always in the unstaged state. To stage them, you need to use the git add command.
commit You associate a group of changes, possibly to multiple files, to a hash value.">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="robots" content="index, follow">
	<meta charset="utf-8">

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>



</head>
<body>
<main>
<header><h1 id="tag_Git and related concepts">Git and related concepts</h1></header>
<article>

<h1 id="basic-usage">Basic usage</h1>
<h2 id="diff">diff</h2>
<p>See my notes on <a href="https://linnabraham.me/notes/understanding_diff/">Understanding Diff</a>.
To see the changes that are brought about by a particular commit in git, do the following:</p>
<pre tabindex="0"><code>git diff &lt;parent-commit&gt;..&lt;current-commit&gt;
</code></pre><h2 id="staging">staging</h2>
<p>The changes that you to immediately make to your git tracked files are always in the <code>unstaged</code> state. To stage them, you need to use the <code>git add</code> command.</p>
<h2 id="commit">commit</h2>
<p>You associate a group of changes, possibly to multiple files, to a <code>hash</code> value. You also associate this <code>hash</code> with a commit message for it to make sense to you why you made these changes.</p>
<h2 id="rebase"><code>rebase</code></h2>
<p>Say that you have cloned a github repo to two different machines. You work on one and push changes back to the remote (github). When you do the same from the other machine you might run into a <code>merge</code> conflict. To solve this, you would have to <code>pull</code> with <code>--rebase</code>.</p>
<h2 id="merge"><code>merge</code></h2>
<p>There are different merge strategies like <code>fast-forward</code>, <code>recursive</code> etc. For non-divergent branches, the default is <code>fast-forward</code>. This is the case when your local branch has no commits that are not there in the remote branch. For divergent branches, the default strategy is <code>recursive</code>.
The <code>git pull</code> command  is basically doing a <code>git fetch</code> and a <code>git merge</code> combined.
If you do not want to do a recursive merge, you can use <code>git merge --ff</code> or <code>git pull --ff</code>.</p>
<h2 id="restore"><code>restore</code></h2>
<p>This is a dangerous command that you need to handle with caution.
This is often used to replace your unstaged changes with a commited version etc.</p>
<h2 id="stash"><code>stash</code></h2>
<p>Use this to stash away uncommitted changes. Often needed when using <code>git pull --rebase</code>.
Stash also has an option to save untracked files.</p>
<h1 id="advanced-usage">Advanced usage</h1>
<h2 id="add---patch">add <code>--patch</code></h2>
<p>You can use the <code>git add</code> command with the <code>-p</code> option to stage specific hunks from the diff instead of staging all the changes made in a file. If git is not able to split the hunk the way you want there is the &ldquo;e&rdquo; option you can give to manually create a hunk.</p>
<h2 id="restore---patch">restore <code>--patch</code></h2>
<p>Restore also supports a patch mode with the <code>-p</code> flag.</p>
<h2 id="amend-and-squash"><code>amend</code> and <code>squash</code></h2>
<p>Both of these are basically rebase operations. One difference between them is that <code>amend</code> only changes the last commit whereas <code>squash</code> is used to combine multiple commits into single commit. Both are useful for keeping a clean commit history (Read more in the official git <a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">docs</a>).
Once you are familiar with the concepts you can start using <code>--fixup</code> commits and <code>--autosquash</code> flags in <code>rebase -i</code> to speed up things.</p>
<h2 id="tags">tags</h2>
<p>Useful when you want to tag your commits with a version number or name or something. Commit messages are often meant to describe the changes that were made. But when you want to associate
a commit with a working version, tags are helpful.</p>
<h2 id="git-prompt"><code>git-prompt</code></h2>
<p>Download the <a href="https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh"><code>git-prompt</code></a> script provided by git somwhere in your machine and source it in your shell.
After than you can customize your default prompt to show basic git information. Check the comments in the script for usage instruction.</p>
<h1 id="optional-usage">Optional usage</h1>
<h2 id="submodules">submodules</h2>
<p>This is useful when you want to nest a git repo inside another.</p>
<h2 id="github-actions">Github actions</h2>
<p>Allows you to have workflows attached to your git push commands.</p>
<h1 id="pitfalls-to-avoid-when-using-git">Pitfalls to avoid when using Git</h1>
<h2 id="having-faithful-commits">Having faithful commits</h2>
<p>If you have a working version of a code. Don&rsquo;t keep modifications that are uncommitted in your staging area. You can use <code>git stash</code> for this purpose.
Once you have a clean repo <code>tag</code> the last commit as the one that has the working version. This is useful if you ever want to revist the state of your repo.
If you have unmodified code lying around and some of those code are direct or indirect dependencies in your primary code you never know what was the actual state of your repo when you commited it. The commit are no longer a faithful representation.
This is also where you should start thinking of version controlling your data.</p>
<h2 id="how-not-to-lose-your-data-while-learning-git">How not to lose your data while learning git</h2>
<p>If you are a beginner who wants to try out certain git commands on your repo but afraid that you might lose data (you should be), then you have two options. Certain commands in git would have an associated <code>dry-run</code> option. Check for that in the docs. If there is no such option then a fail safe alternative is to just create a test branch from your current branch. Test out the things there and once you are satisified, repeat it on the master. Then simply delete the test branch.</p>


<div id="nextprev">
<a href="/software_i_use/"><div id="prevart">Previous:<br>Software I Use</div></a>
<a href="/notes/vim_tips/"><div id="nextart">Next:<br>Vim Tips</div></a>
</div>

</article>

</main>

<footer>
	<a href="https://linnabraham.me/">https://linnabraham.me/</a><br><br><a href="/index.xml"><img src="/rss.svg" style="max-height:1.5em" alt="RSS Feed" title="Subscribe via RSS for updates."></a>
</footer>

</body>
</html>
